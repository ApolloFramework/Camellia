//
//  CellTopologyTests.cpp
//  Camellia
//
//  Created by Nate Roberts on 9/16/14.
//
//

#include "CellTopologyTests.h"

#include "CamelliaDebugUtility.h"

CellTopologyTests::CellTopologyTests() {
  _shardsTopologies.push_back(CellTopology::point());
  _shardsTopologies.push_back(CellTopology::line());
  _shardsTopologies.push_back(CellTopology::quad());
  _shardsTopologies.push_back(CellTopology::triangle());
  _shardsTopologies.push_back(CellTopology::hexahedron());
//  _shardsTopologies.push_back(CellTopology::tetrahedron()); // tetrahedron not yet supported by permutation
}

void CellTopologyTests::setup() {}
void CellTopologyTests::teardown() {}

bool CellTopologyTests::checkDimension(CellTopoPtr cellTopo) {
  return cellTopo->getDimension() == cellTopo->getShardsTopology().getDimension() + cellTopo->getTensorialDegree();
}

bool CellTopologyTests::checkPermutationCount(CellTopoPtr cellTopo) {
  unsigned actualPermutationCount = cellTopo->getNodePermutationCount();
  unsigned expectedPermutationCount;
  if (cellTopo->isHypercube()) {
    expectedPermutationCount = 1;
    for (int d=0; d<cellTopo->getDimension(); d++) {
      expectedPermutationCount *= 2 * (d+1);
    }
  } else {
    int shardsPermutationCount = cellTopo->getShardsTopology().getNodePermutationCount();
    expectedPermutationCount = shardsPermutationCount;
    if (cellTopo->getTensorialDegree() == 1)  expectedPermutationCount *= 2;
    else if (cellTopo->getTensorialDegree() > 1) {
      cout << "Test failure: unsupported tensorial degree.\n";
      return false;
    }
  }
  if (expectedPermutationCount != actualPermutationCount) {
    cout << "FAILURE: expected permutation count " << expectedPermutationCount << " did not match actual " << actualPermutationCount << endl;
  } else {
//    cout << "actual permutation count matches expected: " << actualPermutationCount << endl;
  }
  return (expectedPermutationCount == actualPermutationCount);
}

bool CellTopologyTests::checkPermutations(CellTopoPtr cellTopo) {
  bool success = true;
  map< vector<unsigned>, unsigned > knownPermutations; // from permutation to its ordinal
  // true if all permutations are distinct and inverses do in fact invert
  int permutationCount = cellTopo->getNodePermutationCount();
  int nodeCount = cellTopo->getNodeCount();
  for (unsigned permutationNumber = 0; permutationNumber < permutationCount; permutationNumber++) {
    vector<unsigned> permutedNodes(nodeCount);
    set<unsigned> permutedNodeSet;
    for (unsigned node=0; node<nodeCount; node++) {
      unsigned permutedNode = cellTopo->getNodePermutation(permutationNumber, node);
      permutedNodes[node] = permutedNode;
      unsigned inversePermutedNode = cellTopo->getNodePermutationInverse(permutationNumber, permutedNode);
      permutedNodeSet.insert(permutedNode);
      if (inversePermutedNode != node) {
        success = false;
        cout << "Test failure: permutation number " << permutationNumber << " maps " << node << " to " << permutedNode;
        cout << ", but its inverse maps " << permutedNode << " to " << inversePermutedNode << endl;
      }
    }
    if (permutedNodeSet.size() < permutedNodes.size()) {
      cout << "Test failure: permutation number " << permutationNumber << " has duplicate entries.\n";
      Camellia::print("permutedNodes", permutedNodes );
    }
    if (knownPermutations.find(permutedNodes) != knownPermutations.end()) {
      cout << "Test failure: permutation number " << permutationNumber << " matched a node ordering previously ";
      cout << "generated by permutation number " << knownPermutations[permutedNodes] << endl;
      vector< vector<unsigned> > permList(permutationCount);
      for (map< vector<unsigned>, unsigned >::iterator knownPermIt = knownPermutations.begin(); knownPermIt != knownPermutations.end(); knownPermIt++) {
        permList[knownPermIt->second] = knownPermIt->first;
      }
      for (int i=0; i<permList.size(); i++) {
        ostringstream permNum;
        permNum << "permutation " << i;
        Camellia::print(permNum.str(), permList[i]);
      }
      
      success = false;
    }
    knownPermutations[permutedNodes] = permutationNumber;
  }
  
  return success;
}

void CellTopologyTests::runTests(int &numTestsRun, int &numTestsPassed) {
  setup();
  if (testShardsTopologiesPermutations()) {
    numTestsPassed++;
  }
  numTestsRun++;
  teardown();
  
  setup();
  if (testOneTensorTopologiesPermutations()) {
    numTestsPassed++;
  }
  numTestsRun++;
  teardown();

  setup();
  if (testMultiTensorTopologiesPermutations()) {
    numTestsPassed++;
  }
  numTestsRun++;
  teardown();
}

bool CellTopologyTests::testShardsTopologiesPermutations() {
  bool success = true;
  for (int topoOrdinal=0; topoOrdinal < _shardsTopologies.size(); topoOrdinal++) {
    CellTopoPtr cellTopo = _shardsTopologies[topoOrdinal];
    if (! checkPermutationCount(cellTopo)) {
      cout << "testShardsTopologiesPermutations failed checkPermutationCount() for " << cellTopo->getShardsTopology().getName() << endl;
      success = false;
    }
    if (! checkPermutations(cellTopo)) {
      cout << "testShardsTopologiesPermutations failed for " << cellTopo->getShardsTopology().getName() << endl;
      success = false;
    }
  }
  return success;
}

bool CellTopologyTests::testOneTensorTopologiesPermutations() {
  // one tensorial dimension
  bool success = true;
  int tensorialDegree = 1;
  for (int topoOrdinal=0; topoOrdinal < _shardsTopologies.size(); topoOrdinal++) {
    shards::CellTopology shardsTopo = _shardsTopologies[topoOrdinal]->getShardsTopology();
    CellTopoPtr cellTopo = CellTopology::cellTopology(shardsTopo, tensorialDegree);
    if (! checkDimension(cellTopo)) {
      cout << "testOneTensorTopologiesPermutations failed checkDimension() for " << cellTopo->getShardsTopology().getName() << endl;
      success = false;
    }
    if (! checkPermutationCount(cellTopo)) {
      cout << "testOneTensorTopologiesPermutations failed checkPermutationCount() for " << cellTopo->getShardsTopology().getName() << endl;
      success = false;
    }
    if (! checkPermutations(cellTopo)) {
      cout << "testOneTensorTopologiesPermutations failed for " << cellTopo->getShardsTopology().getName() << endl;
      success = false;
    }
  }
  return success;
}

bool CellTopologyTests::testMultiTensorTopologiesPermutations() {
  bool success = true;
  int minDimension = 1;
  int maxDimension = 4; // tested up to 6, but 4 is all we really are interested in...
  
  vector< CellTopoPtr > shardsHyperCubeTopos;
  shardsHyperCubeTopos.push_back(CellTopology::point());
  shardsHyperCubeTopos.push_back(CellTopology::line());
  shardsHyperCubeTopos.push_back(CellTopology::quad());
  shardsHyperCubeTopos.push_back(CellTopology::hexahedron());
  
  for (int shardsOrdinal=0; shardsOrdinal<shardsHyperCubeTopos.size(); shardsOrdinal++) {
    shards::CellTopology shardsTopo = shardsHyperCubeTopos[shardsOrdinal]->getShardsTopology();
    
    int minTensorialDegree = (minDimension > shardsTopo.getDimension()) ? minDimension - shardsTopo.getDimension() : 0;
    int maxTensorialDegree = (minDimension > shardsTopo.getDimension()) ? maxDimension - shardsTopo.getDimension() : 0;
    
    for (int tensorialDegree=minTensorialDegree; tensorialDegree <= maxTensorialDegree; tensorialDegree++) {
      CellTopoPtr cellTopo = CellTopology::cellTopology(shardsTopo, tensorialDegree);
      
      if (! checkDimension(cellTopo)) {
        cout << "testMultiTensorTopologiesPermutations failed checkDimension() for " << cellTopo->getShardsTopology().getName() << endl;
        success = false;
      }
      if (! checkPermutationCount(cellTopo)) {
        cout << "testMultiTensorTopologiesPermutations failed checkPermutationCount() for " << cellTopo->getShardsTopology().getName() << endl;
        success = false;
      }
      if (! checkPermutations(cellTopo)) {
        cout << "testMultiTensorTopologiesPermutations failed for " << cellTopo->getShardsTopology().getName();
        cout << " with tensorial degree " << tensorialDegree << endl;
        success = false;
      }
    }
  }
  return success;
}
